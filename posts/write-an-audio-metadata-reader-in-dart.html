<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="ie=edge"/><title>Write an audio metadata reader in Dart</title><meta name="description" content="Introduction to how I built my audio metadata reader library"/><link rel="icon" href="favicon.ico" type="image/x-icon"/><link rel="stylesheet" href="/assets/style.css"/><style></style><link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&amp;display=swap" rel="stylesheet"/><script src="https://cdn.tailwindcss.com"></script><!-- For color syntax --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css"/><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/dart.min.js"></script><script>hljs.highlightAll();</script></head><body class="flex flex-col pb-20"><nav class="sticky top-0 mb-10 h-20 shadow border-bottom-2 z-10 bg-blue-600 text-white flex items-center px-8"><div class="w-full sm:w-3/5 sm:mx-auto flex justify-between"><div class="flex gap-4"><a href="/" class="text-white">Home</a><a href="/projects" class="text-white">Projects</a></div><div class="flex gap-4"><a href="https://twitter.com/clementbdev" target="_blank" class="text-white">Twitter</a><a href="https://github.com/ClementBeal" target="_blank" class="text-white">Github</a><a href="/rss.xml" class="text-white" target="_blank">RSS</a></div></div></nav><main class="sm:w-3/5 mx-auto border border-1 p-8 rounded-lg gap-4"><div class="markdown-content"><h1>Write an Audio Metadata Reader in Dart</h1><hr/><p>A while ago, I tried to build my own music player. Flutter is great for this use case because of its multiplatform capabilities.</p><p>What do we need to build a good music player? A library to read audio metadata. The metadata is information about the artist's name, the album's name, the track number, the length, the release year, the cover image... Tons of very useful information we must display to the user.</p><p>During my journey, I searched for a suitable library that met my needs.</p><p>Let's start with<code>metadata_god</code>. This library serves as a bridge to the Rust library<code>lofty-rs</code>. It functions reasonably well but does not provide all the metadata I required. I attempted to fork the repository and submit a pull request (PR) to address the issue. However, fixing the problem required me to learn Rust, comprehend the<code>lofty-rs</code>library (which is rather complex), submit my PR, wait for its approval and merging, then submit another PR to<code>metadata_god</code>and wait again. Additionally, the<code>flutter_rust_bridge</code>only works for Flutter apps, not for simple Dart CLI apps.</p><p>When I tried to parse my music folder (3000 tracks, 29GB), the libraries couldn't parse some tracks:</p><pre><code class="language-ruby">[ERROR:flutter/runtime/dart_vm_initializer.cc(41)] Unhandled Exception: Instance of 'FrbAnyhowException'</code></pre><p>If I wrapped the<code>readMetadata</code>function with a try/catch, I caught 87 errors and it took<strong>2.3s</strong>to read all the metadata and keep the cover data in memory.</p><p>The other library I investigated is called<code>flutter_media_metadata</code>. It serves as a bridge between Flutter and a C++ library. For some obscure reasons, the library doesn't work anymore on my Linux system. When I tried it, it was slow... very slow. I'm using an app called<code>Harmonoid</code>that implements this library and it took<strong>44s</strong>to index my folder.</p><p>All these libraries are essentially bridges with another library but we lack a native Dart library. So why not develop a Dart library to read audio metadata? Reading metadata is IO-bound and Dart performs well in such scenarios. Additionally, I recall that a<code>flutter_rust_bridge</code>library weighs at least<strong>3MB</strong>so developing a native Dart library could potentially reduce the app size.</p><p>Let's now delve into the marvelous world of audio containers and binary formats! This article serves more as an introduction to audio metadata readers, where we'll only scratch the surface of the specifications of audio metadata, rather than being a comprehensive Dart/Flutter tutorial.</p><h2>ID3 Tag</h2><p>ID3 is the metadata format used by<code>mp3</code>and other audio formats. 4 versions are used:<code>v1</code>,<code>v2</code>,<code>v3</code>,<code>v4</code>.</p><p>First, we read the 10 first bytes of the file. The 3 first bytes must be equal to<code>ID3</code>. With this information, we will disregard the file extension entirely and focus solely on the bytes. Bytes 4 and 5 indicate the major and minor version of the ID3 tag, while the remaining bytes represent the size of the content of the ID3 tag.</p><p>Now, we can parse the frames. Each frame consists of a header and its content. The header contains an "ID" that informs us about the type of content it represents, such as the album's name, the length of the content, and some flags. We continue reading frames until we reach the end of the content.</p><p>The frame ID consists of 4 bytes. We utilize a switch statement to extract the information based on the frame ID. For example, TALB represents the album's name, TBPM represents the BPM, and so on.</p><p>The duration of the track is not always written in the metadata; therefore, we have to calculate it. To do this, we need to read the first MP3 frame, extract the bitrate and the frequency, and then use a simple formula to calculate the duration.</p><h2>MP4 Metadata</h2><p>First, to verify that the file uses MP4 metadata, the 4 first bytes must be equal to<code>ftyp</code>.</p><p>This format can be a bit complex. It's composed of nested boxes that provide information about various aspects such as audio bitrate, video bitrate, and so on.</p><hr/><p><strong>box 1</strong></p><hr/><p><strong>box 2</strong></p><hr/><p><strong>box 3</strong></p><ul><li>artist</li><li>album</li><li>disc</li></ul><p><em>The nested boxes</em></p><hr/><p>The strategy involves reading the header of a box, which contains information about the box name and its size. MP4 metadata consists of a list of predefined boxes that we can utilize. We navigate through these boxes until we encounter a box with a name starting with<code>Â©</code>. There are a few of them, each defining specific information.</p><p>The box<code>mvhd</code>contains the bitrate and the frequency, allowing us to compute the track's duration once again.</p><h2>Vorbis Comment</h2><p>This one is straightforward. I will only handle<code>flac</code>, but the code structure is nearly identical for ogg, vorbis, and opus formats.</p><p>The flac file consists of blocks, each identified by an ID between 0 and 127. IDs between 0 and 6 hold special significance. We will read blocks with IDs 0 (streaminfo), 4 (vorbis comment), and 6 (picture).</p><p>From block 0, we will extract the samplerate, bits per sample, and the total samples in the stream. Now, the formula<code>totalSamplesInStream / sampleRate * 1000</code>provides us with the duration of the track.</p><p>Block 4 contains the current metadata. In comparison with ID3, there isn't as much information. All the information is defined in the specifications of the Vorbis Comments. They are structured like this:<code>ARTIST=ACDC</code>.</p><p>Block 6 contains the data for one picture. We can determine whether the picture is the front or back cover of the album, and it's possible to have more than one picture.</p><h2>Conclusion</h2><p>First, I've learned that implementing these metadata readers is challenging not because the code to write is complex, but because the documentation is difficult to find, not freely accessible, or not sufficiently clear.</p><p>Now that the library is complete and ready to crawl my music folder, I run the code and... it's very fast. It only needs<strong>0.9s</strong>to parse all my tracks.</p><p>The compressed package size is only<strong>30kb</strong>. It means that after the compilation, we would probably have something smaller. On the other side,<code>MetadataGod</code>adds a<code>.so</code>file of<strong>6MB</strong>on Linux, and the Android apk is<strong>2.7MB</strong>bigger.</p><p>It shows that it can be worth to write IO-bound libraries in Dart instead of using a bridge to a C++/Rust library. It makes the maintenance by the Dart/Flutter easier and faster. And because the code is pure Dart, we have guarantee that it will work the same for every platform!</p><p>If I add to emit a critique about my current library, I'd say it's incomplete. We can only read metadata, not write or edit them. I don't think it would be very hard to implement, just annoying because it would need to recompute all the<code>length</code>fields for every format.</p><p><a href="https://github.com/ClementBeal/audio_metadata_reader">Link to the Github</a></p></div></main></body></html>